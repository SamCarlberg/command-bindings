import { Controller } from "./Controller"
import { AtomicCommand, Subsystem } from "./Command"
import { v4 as uuidV4 } from "uuid"
import * as IR from "../bindings/ir"
import { BundledMain } from "../bundled_files/Main.java"
import { BundledGitignore } from "../bundled_files/.gitignore"
import { generateBundledPreferences } from "../bundled_files/wpilib_preferences.json"
import { generateRobotClass } from "../codegen/java/RobotGenerator"
import { BundledGradleBuild } from "../bundled_files/build.gradle"
import { generateReadme } from "../bundled_files/README.md"
import { BundledLaunchJson, BundledSettingsJson } from "../bundled_files/vscode"
import { BundledWpilibCommandsV2 } from "../bundled_files/vendordeps"
import { className } from "../codegen/java/util"
import { generateSubsystem } from "../codegen/java/SubsystemGenerator"
import { ALL_SETTINGS } from "../settings/Settings"

export type GeneratedFile = {
  name: string
  description: string
  contents?: string
  hidden?: boolean
}

export type Project = {
  controllers: Controller[]
  subsystems: Subsystem[]
  commands: IR.Group[]
  generatedFiles: GeneratedFile[]
  settings: Settings
};

export type SettingsKey = string
export type SettingsType = string | number | boolean | null
export type SettingsTypeName = "string" | "number" | "boolean"

export type Settings = Record<SettingsKey, SettingsType>

export type SettingsCategory = {
  key: string
  name: string
  settings: SettingConfig[]
}

export type SettingConfig = {
  /**
   * A unique key to identify this setting. For example, a UUID or a unique identifier like "wpilib.epilogue.enabled".
   */
  key: SettingsKey

  /**
   * The name of the setting to display to users.
   */
  name: string

  /**
   * A description of this setting and what it does or how it's used.
   */
  description: string

  /**
   * Whether or not the setting is required.
   */
  required: boolean

  /**
   * The data type of the setting object. This will be used to determine the UI element that edits this setting.
   */
  type: SettingsTypeName

  /**
   * The default value of the setting.
   */
  defaultValue: SettingsType
}

const makeDefaultGeneratedFiles = (): GeneratedFile[] => {
  return [
    {
      name: ".vscode/launch.json",
      description: "",
      contents: BundledLaunchJson,
    },
    {
      name: ".vscode/settings.json",
      description: "",
      contents: BundledSettingsJson,
    },
    {
      name: ".wpilib/wpilib_preferences.json",
      description: "",
      contents: "",
    },
    {
      name: ".gitignore",
      description: "",
      contents: BundledGitignore,
    },
    {
      name: "build.gradle",
      description: "The build file that controls how the program is compiled and deployed",
      contents: BundledGradleBuild,
    },
    {
      name: "README.md",
      description: "A readme file that gives some overview of the project",
      contents: `<!-- TODO: README.md template -->`,
    },
    {
      name: "src/main/java/frc/robot/subsystems/.gitkeep",
      description: "",
      hidden: true,
    },
    {
      name: "src/main/java/frc/robot/Main.java",
      description: "The Java main class used to start the program. Do not edit this file.",
      contents: BundledMain,
    },
    {
      name: "src/main/java/frc/robot/Robot.java",
      description: "The main robot class",
      contents: null,
    },
    {
      name: "vendordeps/WPILibNewCommands.json",
      description: "Vendordep file for the V2 command framework",
      contents: BundledWpilibCommandsV2,
    },
  ]
}

export const makeNewProject = (): Project => {
  const project: Project = {
    controllers: [
      { name: "New Controller", uuid: uuidV4(), type: "ps5", className: "CommandPS5Controller", fqn: "", port: 1 , buttons: [] },
    ],
    subsystems: [],
    commands: [],
    generatedFiles: makeDefaultGeneratedFiles(),
    settings: { },
  }

  for (const categoryKey in ALL_SETTINGS) {
    const category: SettingsCategory = ALL_SETTINGS[categoryKey]
    category.settings.forEach(setting => {
      project.settings[setting.key] = setting.defaultValue
    })
  }
  
  // Update pregenerated files to give them a valid initial state
  // These files may need to be updated over time while the project is edited
  updateFile(project, ".wpilib/wpilib_preferences.json",  generateBundledPreferences(project))
  updateFile(project, "src/main/java/frc/robot/Robot.java", generateRobotClass(project))
  updateFile(project, "README.md", generateReadme(project))

  return project
}

export function updateFile(project: Project, path: string, contents: string): void {
  project.generatedFiles.find(f => f.name === path).contents = contents
}

/**
 * Regenerates all dynamic project files.
 * 
 * @param project the project to regenerate
 */
export function regenerateFiles(project: Project): void {
  // Regenerate subsystems
  project.subsystems.forEach(subsytem => {
    updateFile(project, `src/main/java/frc/robot/subsystems/${ className(subsytem.name) }.java`, generateSubsystem(subsytem, project))
  })
  
  updateFile(project, "src/main/java/frc/robot/Robot.java", generateRobotClass(project))

  updateFile(project, `README.md`, generateReadme(project))
  updateFile(project, ".wpilib/wpilib_preferences.json", generateBundledPreferences(project))
}

export function findCommand(project: Project, commandOrId: AtomicCommand | IR.Group | string): AtomicCommand | IR.Group | null {
  if (commandOrId instanceof AtomicCommand || commandOrId instanceof IR.Group) {
    // Passed in a command object, return it
    return commandOrId
  }

  const projectCommand = project.commands.find(c => c.uuid === commandOrId)
  if (projectCommand) return projectCommand

  const subsystemCommand = project.subsystems.flatMap(p => p.commands).find(c => c.uuid === commandOrId)
  if (subsystemCommand) return subsystemCommand

  console.warn("[findCommand] Could not find a command with UUID", commandOrId)
  return null
}

import { Controller } from "./Controller"
import { AtomicCommand, Subsystem } from "./Command"
import { v4 as uuidV4 } from "uuid"
import * as IR from "../bindings/ir"
import { BundledMain } from "../bundled_files/Main.java"
import { BundledGitignore } from "../bundled_files/.gitignore"
import { generateBundledPreferences } from "../bundled_files/wpilib_preferences.json"
import { generateRobotClass } from "../codegen/java/RobotGenerator"
import { BundledGradleBuild } from "../bundled_files/build.gradle"
import { generateReadme } from "../bundled_files/README.md"
import { BundledLaunchJson, BundledSettingsJson } from "../bundled_files/vscode"
import { BundledWpilibCommandsV2 } from "../bundled_files/vendordeps"
import { className } from "../codegen/java/util"
import { generateSubsystem } from "../codegen/java/SubsystemGenerator"

export type GeneratedFile = {
  name: string
  description: string
  contents?: string
  hidden?: boolean
}

export type Project = {
  name: string
  controllers: Controller[]
  subsystems: Subsystem[]
  commands: IR.Group[]
  generatedFiles: GeneratedFile[]
  settings: Settings
};

export type Settings = {
  /**
   * The number of the FRC team the project targets. This is used in the wpilib_preferences.json file
   * and in the build.gradle file. Defaults to 0; users will need to change it to their team number
   * before being able to export.
   */
  teamNumber: number

  /**
   * Whether or not to include Epilogue logging support in generated files. Defaults to `true`.
   */
  epilogueSupport: boolean

  /**
   * Any custom project settings provided by third party extensions.
   */
  custom: Record<string, unknown>
}

const makeDefaultGeneratedFiles = (): GeneratedFile[] => {
  return [
    {
      name: ".vscode/launch.json",
      description: "",
      contents: BundledLaunchJson,
    },
    {
      name: ".vscode/settings.json",
      description: "",
      contents: BundledSettingsJson,
    },
    {
      name: ".wpilib/wpilib_preferences.json",
      description: "",
      contents: "",
    },
    {
      name: ".gitignore",
      description: "",
      contents: BundledGitignore,
    },
    {
      name: "build.gradle",
      description: "The build file that controls how the program is compiled and deployed",
      contents: BundledGradleBuild,
    },
    {
      name: "README.md",
      description: "A readme file that gives some overview of the project",
      contents: `<!-- TODO: README.md template -->`,
    },
    {
      name: "src/main/java/frc/robot/subsystems/.gitkeep",
      description: "",
      hidden: true,
    },
    {
      name: "src/main/java/frc/robot/Main.java",
      description: "The Java main class used to start the program. Do not edit this file.",
      contents: BundledMain,
    },
    {
      name: "src/main/java/frc/robot/Robot.java",
      description: "The main robot class",
      contents: null,
    },
    {
      name: "vendordeps/WPILibNewCommands.json",
      description: "Vendordep file for the V2 command framework",
      contents: BundledWpilibCommandsV2,
    },
  ]
}

export const makeNewProject = (): Project => {
  const project: Project = {
    name: "",
    controllers: [
      { name: "New Controller", uuid: uuidV4(), type: "ps5", className: "CommandPS5Controller", fqn: "", port: 1 , buttons: [] },
    ],
    subsystems: [],
    commands: [],
    generatedFiles: makeDefaultGeneratedFiles(),
    settings: {
      teamNumber: 0,
      epilogueSupport: true,
      custom: {},
    },
  } 
  
  // Update pregenerated files to give them a valid initial state
  // These files may need to be updated over time while the project is edited
  updateFile(project, ".wpilib/wpilib_preferences.json",  generateBundledPreferences(project))
  updateFile(project, "src/main/java/frc/robot/Robot.java", generateRobotClass(project))
  updateFile(project, "README.md", generateReadme(project))

  return project
}

export function updateFile(project: Project, path: string, contents: string): void {
  project.generatedFiles.find(f => f.name === path).contents = contents
}

/**
 * Regenerates all dynamic project files.
 * 
 * @param project the project to regenerate
 */
export function regenerateFiles(project: Project): void {
  // Regenerate subsystems
  project.subsystems.forEach(subsytem => {
    updateFile(project, `src/main/java/frc/robot/subsystems/${ className(subsytem.name) }.java`, generateSubsystem(subsytem, project))
  })
  
  updateFile(project, "src/main/java/frc/robot/Robot.java", generateRobotClass(project))

  updateFile(project, `README.md`, generateReadme(project))
  updateFile(project, ".wpilib/wpilib_preferences.json", generateBundledPreferences(project))
}

export function findCommand(project: Project, commandOrId: AtomicCommand | IR.Group | string): AtomicCommand | IR.Group | null {
  if (commandOrId instanceof AtomicCommand || commandOrId instanceof IR.Group) {
    // Passed in a command object, return it
    return commandOrId
  }

  const projectCommand = project.commands.find(c => c.uuid === commandOrId)
  if (projectCommand) return projectCommand

  const subsystemCommand = project.subsystems.flatMap(p => p.commands).find(c => c.uuid === commandOrId)
  if (subsystemCommand) return subsystemCommand

  console.warn("[findCommand] Could not find a command with UUID", commandOrId)
  return null
}
